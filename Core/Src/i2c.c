/**
  ******************************************************************************
  * @file    i2c.h
  * @author  Marco, Roldan L.
  * @version v1.0
  * @date    August 27, 2021
  * @brief   I2C peripheral driver
  *   
  *          The I2C APIs present here follows the transfer sequence for reading 
  *          and writing described in the reference manual (RM0008).
  * 
  *          Device used: Bluepill (STM32F103C8)
  ******************************************************************************
  *
  * Copyright (C) 2021  Marco, Roldan L.
  * 
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * any later version.
  * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see https://www.gnu.org/licenses/gpl-3.0.en.html.
  * 
  * 
  * https://github.com/rmarco30
  * 
  ******************************************************************************
**/

#include "stm32f10x.h"
#include "i2c.h"



/* I2C enums */
typedef enum
{
    NACK = 0,
    ACK = !NACK
} i2cAckBit_t;


/* Static function prototypes */

static void i2c_config(void);
static void i2c_gpio(void);
static void i2c_ack_bit(i2cAckBit_t ack_nack);





/**
 * @brief    Initializes I2C1 and its GPIO
 * @param    none
 * @retval   none
 */
void i2c_init(void)
{
    /* Small delay to ensures stable VDD */
    for(uint16_t i = 0; i < 1000; i++);
    i2c_gpio();
    i2c_config();
}



/**
 * @brief    Issue a start condition. When this function is
 *           called without calling stop first then this will
 *           be treated as a restart condition.
 * @param    none
 * @retval   none
 */
void i2c_start(void)
{
    I2C1->CR1 |= I2C_CR1_START;
}



/**
 * @brief    Issue a stop condition to release the line
 * @param    none
 * @retval   none
 */
void i2c_stop(void)
{
    I2C1->CR1 |= I2C_CR1_STOP;
}



/**
 * @brief    Issue a ACK or NACK. This function is not usually
 *           called explicitly, most of the time this is
 *           auto-generated by the hardware.
 * @param    ack_bit: ACK or NACK
 * @retval   none
 */
static void i2c_ack_bit(i2cAckBit_t ack_bit)
{
    if(ack_bit)
    {
        I2C1->CR1 |= I2C_CR1_ACK;
    }
    else
    {
        I2C1->CR1 &= ~(I2C_CR1_ACK);
    }
}



/**
 * @brief    This function is called after issuing a start condition,
 *           this initiates the communication to slave device.
 * @param    slave_addr_rw: pre-shifted slave address and pre-appended RnW bit
 * @retval   none
 */
void i2c_request(uint8_t slave_addr_rw)
{
    /* EV5 - SB = 1 */
    while( !(I2C1->SR1 & I2C_SR1_SB) );         
    I2C1->DR = slave_addr_rw;

    /* EV6 - ADDR = 1 */
    while( !((I2C1->SR1 & I2C_SR1_ADDR)) );     
}



/**
 * @brief    Transmit a byte of data
 * @param    data: 1 byte data to be transmitted
 * @retval   none
 */
void i2c_write(uint8_t data)
{
    /* EV6 - address matched, ADDR = 1. Clear ADDR bit */
    I2C1->SR2 = I2C1->SR2;
    /* EV8_1 - Write data to DR */
    while ( !(I2C1->SR1 & I2C_SR1_TXE ));
    I2C1->DR = data;
    /* EV8_2 - data byte transmitted */
    while( (!(I2C1->SR1 & I2C_SR1_BTF)) && (!(I2C1->SR1 & I2C_SR1_TXE)) );
    /* Issue a stop condition after exiting this function */
}



/**
 * @brief    Transmit a N byte of data
 * @param    mode: MASTER or SLAVE transmitter
 * @param    data_bytes: number of bytes to transmit
 * @param    data_buffer: pointer to array where data are stored
 * @retval   none
 */
void i2c_write_burst(i2cMode_t mode, uint8_t data_bytes, uint8_t *data_buffer)
{
    if( mode )
    {
        /* EV6 - address matched, ADDR = 1. Clear ADDR bit */
        I2C1->SR2 = I2C1->SR2;
        /* EV8_1 - Loop through the buffer to transmit data */
        for(uint8_t i = 0; i != data_bytes; i++)
        {
            while ( !(I2C1->SR1 & I2C_SR1_TXE) );   
            I2C1->DR = *(data_buffer + i);
        }
        /* EV8_2 - All data bytes transmitted */
        while( (!(I2C1->SR1 & I2C_SR1_BTF)) || (!(I2C1->SR1 & I2C_SR1_TXE)) );
        /* Issue a stop condition after exiting this function */
    }
    else
    {
        /* Set ACK bit before transmission starts */
        i2c_ack_bit(ACK);
        /* EV1 - Address matched, clear ADDR bit */
        while( !((I2C1->SR1 & I2C_SR1_ADDR)) );
        I2C1->SR2 = I2C1->SR2;

        uint8_t j = 0;
        /* EV3-1 - Loop through the buffer to transmit
           data until NACK is received */
        while( !(I2C1->SR1 & I2C_SR1_AF) )
        {
            if(data_bytes > 1)
            {
                I2C1->DR = *(data_buffer + j);
                j++;
            }
            else
            {
                I2C1->DR = *(data_buffer);
            }
            /* Wait for ACK from master after each byte */
            while ( !(I2C1->SR1 & I2C_SR1_TXE) );
        }
        /* EV3-2 - NACK received, AF = 1, clear AF bit */
        I2C1->SR1 &= ~( I2C_SR1_AF );
    }
}



/**
 * @brief    Receives a byte of data
 *           Note: Stop condition is not required to call explicitly
 *           after each call to this function. This receiving sequence
 *           handles it already.
 * @param    none
 * @retval   1 byte of data from slave
 */
uint8_t i2c_read(void)
{
    /* This procedure is only applicable for 1 byte reception */

    /* Clear ACK bit before reception starts */
    i2c_ack_bit(NACK);
    /* EV6_3 - Clear ADDR bit, issue a stop condition */
    I2C1->SR2 = I2C1->SR2;
    i2c_stop();

    /* EV7 - Data byte received, read DR */
    while( !(I2C1->SR1 & I2C_SR1_RXNE) );
    return I2C1->DR;
}



/**
 * @brief    Receives N bytes of data (N must be >= 2)
 *           Note: Stop condition is not required to call explicitly
 *           after each call to this function. This receiving sequence
 *           handles it already.
 * @param    mode: MASTER or SLAVE receiver
 * @param    data_bytes: number of bytes to receive. When in SLAVE mode
 *                       this parameter is ignored.
 * @param    data_buffer: pointer to array where data will be stored
 * @retval   none
 */
void i2c_read_burst(i2cMode_t mode, uint8_t data_bytes, uint8_t *data_buffer)
{
    if( mode )
    {
        if(data_bytes == 2)
        {
            /* This procedure is only applicable for 2 bytes reception */

            /* Set POS and ACK bit before reception starts */
            I2C1->CR1 |= I2C_CR1_POS;
            i2c_ack_bit(ACK);

            /* EV6 - Clear ADDR1 then clear ACK bit */
            I2C1->SR2 = I2C1->SR2;
            i2c_ack_bit(NACK);
            
            /* EV7_3 - Data1 in DR, Data2 in shift register, BTF is set */
            while( !(I2C1->SR1 & I2C_SR1_BTF) );
            i2c_stop();

            /* Read Data1 */
            *(data_buffer + 0) = I2C1->DR;
            /* Read Data2 */
            *(data_buffer + 1) = I2C1->DR;
        }

        else if(data_bytes > 2)
        {
            /* This procedure is only applicable for reception of N > 2 bytes */

            /* Set ACK bit to automatically send ack after each byte */
            i2c_ack_bit(ACK);

            /* EV6 - Clear ADDR1 */
            I2C1->SR2 = I2C1->SR2;

            uint8_t j = 0;
            /* EV7 - Receive each byte until only 3 remains */
            for(uint8_t i = data_bytes; i != 3; i--)
            {
                while( !(I2C1->SR1 & I2C_SR1_RXNE) );
                *(data_buffer + j) = I2C1->DR;
                j++;
            }

            /* When 3 bytes remain to read */

            /* EV7_2 - DataN-2 in DR, DataN-1 in shift register,
            BTF is set, clear the ACK bit to NACK the last byte (DataN),
            issue a stop after reading DataN-2 */
            while( !(I2C1->SR1 & I2C_SR1_BTF) );
            i2c_ack_bit(NACK);
            
            /* Read DataN-2, this will move DataN-1 to DR, and receive
            DataN to shift register */
            *(data_buffer + j) = I2C1->DR;              
            j++;
            i2c_stop();

            /* Read DataN-1, DataN will move to DR*/
            while( !(I2C1->SR1 & I2C_SR1_BTF) );
            *(data_buffer + j) = I2C1->DR;              
            j++;

            /* Read DataN, all bytes received, NACK will be automatically
            generated */
            *(data_buffer + j) = I2C1->DR;              
            j++;        
        }

        else
        {
            /* data_bytes must be >= 2 */
            while(1);
        }
    }

    else
    {
        /* Set ACK bit before reception starts */
        i2c_ack_bit(ACK);
        /* EV1 - Address matched, clear ADDR bit */
        while( !((I2C1->SR1 & I2C_SR1_ADDR)) );
        I2C1->SR2 = I2C1->SR2;

        uint8_t j = 0;
        while( !(I2C1->SR1 & I2C_SR1_STOPF) )
        {
            /* EV2 - Receive each byte */
            while( (I2C1->SR1 & I2C_SR1_RXNE) )
            {
                *(data_buffer + j) = I2C1->DR;
                j++;
            }
        }
        /* EV4 - Stop bit detected */
        I2C1->CR1 = I2C1->CR1;
    }
}



/**
 * @brief    Initialize the I2C1 with minimal configuration
 * @param    none
 * @retval   none
 */     
static void i2c_config(void)
{
    /* Perform a I2C peripheral reset */
    I2C1->CR1 |= I2C_CR1_SWRST;
    for(uint8_t i = 0; i < 100; i++);
    I2C1->CR1 &= ~( I2C_CR1_SWRST );

    /* Set this mcu's slave address */
    I2C1->OAR1 |= ( STM32F1_SLV_ADDR << 1 );

    /* Peripheral clock frequency 36 MHz */
    I2C1->CR2 = 0x24;

    /* I2C fast mode */
    I2C1->CCR |= I2C_CCR_FS;

    /* Configure I2C SCL to 100 KHz */
    // I2C1->CCR = 0xB4;
    /* Configure I2C SCL to 400 KHz */
    I2C1->CCR = 0x2D;

    /* Configure SCL rise time */
    // I2C1->TRISE = 0x25;
    I2C1->TRISE = 10;

    /* Enable I2C1 */
    I2C1->CR1 |= I2C_CR1_PE;
}



/**
 * @brief    Configure I2C1 associated pins (SDA1/SCL1)
 * @param    none
 * @retval   none
 */
static void i2c_gpio(void)
{
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    RCC->APB2ENR |= ( RCC_APB2ENR_AFIOEN | RCC_APB2ENR_IOPBEN );

    /* PB6 - SCL, PB7 - SDA  */
    /* Alternate function output Open-drain, 50 MHz */

    GPIOB->CRL &= ~( GPIO_CRL_CNF6_1 | GPIO_CRL_CNF6_0 |
                     GPIO_CRL_MODE6_1 | GPIO_CRL_MODE6_0 );

    GPIOB->CRL &= ~( GPIO_CRL_CNF7_1 | GPIO_CRL_CNF7_0 |
                     GPIO_CRL_MODE7_1 | GPIO_CRL_MODE7_0 );

    GPIOB->CRL |= ( GPIO_CRL_CNF6_1 | GPIO_CRL_CNF6_0 | GPIO_CRL_MODE6_1 | GPIO_CRL_MODE6_0 );
    GPIOB->CRL |= ( GPIO_CRL_CNF7_1 | GPIO_CRL_CNF7_0 | GPIO_CRL_MODE7_1 | GPIO_CRL_MODE7_0 );

    GPIOB->BSRR |= ( GPIO_BSRR_BS6 | GPIO_BSRR_BS7 );
}